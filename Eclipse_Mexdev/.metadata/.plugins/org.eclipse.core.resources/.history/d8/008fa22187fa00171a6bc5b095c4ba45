#include "mex.h"

/* computational subroutine */
void convec( double *xr, double *xi, size_t nx,
             double *yr, double *yi, size_t ny,
             double *zr, double *zi);

/* The gateway routine. */
void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[] )
{
    double  *xr, *xi, *yr, *yi, *zr, *zi;
    size_t rows, cols;
    size_t nx, ny;

    rows = 1;

    /* get the length of each input vector */
    nx = mxGetN(prhs[0]);
    ny = mxGetN(prhs[1]);


    /* get pointers to the real and imaginary parts of the inputs */
    xr = mxGetPr(prhs[0]);
    xi = mxGetPi(prhs[0]);
    yr = mxGetPr(prhs[1]);
    yi = mxGetPi(prhs[1]);

    /* create a new array and set the output pointer to it */
    cols = nx + ny - 1;
    plhs[0] = mxCreateDoubleMatrix( (mwSize)rows, (mwSize)cols, mxCOMPLEX);
    zr = mxGetPr(plhs[0]);
    zi = mxGetPi(plhs[0]);

    /* call the C subroutine */
    convec(xr, xi, nx, yr, yi, ny, zr, zi);

    return;
}

void convec( double *xr, double *xi, size_t nx,
             double *yr, double *yi, size_t ny,
             double *zr, double *zi)
{
    mwSize i,j;

    zr[0]=0.0;
    zi[0]=0.0;
    /* perform the convolution of the complex vectors */
    for(i=0; i<nx; i++) {
        for(j=0; j<ny; j++) {
            *(zr+i+j) = *(zr+i+j) + *(xr+i) * *(yr+j) - *(xi+i) * *(yi+j);
            *(zi+i+j) = *(zi+i+j) + *(xr+i) * *(yi+j) + *(xi+i) * *(yr+j);
        }
    }
}
